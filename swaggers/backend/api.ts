/* tslint:disable */
/* eslint-disable */
/**
 * Boumboum API
 * The Boumboum API
 *
 * The version of the OpenAPI document: 1.0
 * 
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */


import type { Configuration } from './configuration';
import type { AxiosPromise, AxiosInstance, RawAxiosRequestConfig } from 'axios';
import globalAxios from 'axios';
// Some imports not used depending on template conditions
// @ts-ignore
import { DUMMY_BASE_URL, assertParamExists, setApiKeyToObject, setBasicAuthToObject, setBearerAuthToObject, setOAuthToObject, setSearchParams, serializeDataIfNeeded, toPathString, createRequestFunction } from './common';
import type { RequestArgs } from './base';
// @ts-ignore
import { BASE_PATH, COLLECTION_FORMATS, BaseAPI, RequiredError, operationServerMap } from './base';

/**
 * 
 * @export
 * @interface ApiBadRequestErrorData
 */
export interface ApiBadRequestErrorData {
    /**
     * 
     * @type {Array<ApiBadRequestErrorMessage>}
     * @memberof ApiBadRequestErrorData
     */
    'message': Array<ApiBadRequestErrorMessage>;
    /**
     * 
     * @type {string}
     * @memberof ApiBadRequestErrorData
     */
    'error': string;
    /**
     * 
     * @type {number}
     * @memberof ApiBadRequestErrorData
     */
    'statusCode': number;
}
/**
 * 
 * @export
 * @interface ApiBadRequestErrorMessage
 */
export interface ApiBadRequestErrorMessage {
    /**
     * 
     * @type {Constraints}
     * @memberof ApiBadRequestErrorMessage
     */
    'constraints': Constraints;
    /**
     * 
     * @type {string}
     * @memberof ApiBadRequestErrorMessage
     */
    'property': string;
}
/**
 * 
 * @export
 * @interface ApiNoContentResponseErrorData
 */
export interface ApiNoContentResponseErrorData {
    /**
     * 
     * @type {string}
     * @memberof ApiNoContentResponseErrorData
     */
    'message': string;
    /**
     * 
     * @type {string}
     * @memberof ApiNoContentResponseErrorData
     */
    'error': string;
    /**
     * 
     * @type {number}
     * @memberof ApiNoContentResponseErrorData
     */
    'statusCode': number;
}
/**
 * 
 * @export
 * @interface ApiUnauthorizedResponseErrorData
 */
export interface ApiUnauthorizedResponseErrorData {
    /**
     * 
     * @type {string}
     * @memberof ApiUnauthorizedResponseErrorData
     */
    'message': string;
    /**
     * 
     * @type {number}
     * @memberof ApiUnauthorizedResponseErrorData
     */
    'statusCode': number;
}
/**
 * 
 * @export
 * @interface AuthenticateUserResponse
 */
export interface AuthenticateUserResponse {
    /**
     * 
     * @type {string}
     * @memberof AuthenticateUserResponse
     */
    'access_token': string;
    /**
     * 
     * @type {string}
     * @memberof AuthenticateUserResponse
     */
    'refresh_token': string;
    /**
     * 
     * @type {string}
     * @memberof AuthenticateUserResponse
     */
    'id': string;
}
/**
 * 
 * @export
 * @interface Constraints
 */
export interface Constraints {
    /**
     * 
     * @type {string}
     * @memberof Constraints
     */
    'whitelistValidation': string;
    /**
     * 
     * @type {string}
     * @memberof Constraints
     */
    'maxLength': string;
}
/**
 * 
 * @export
 * @interface CreateOneProfileBody
 */
export interface CreateOneProfileBody {
    /**
     * 
     * @type {string}
     * @memberof CreateOneProfileBody
     */
    'name': string;
    /**
     * 
     * @type {string}
     * @memberof CreateOneProfileBody
     */
    'description'?: string;
    /**
     * 
     * @type {Date}
     * @memberof CreateOneProfileBody
     */
    'dateOfBirth': Date;
    /**
     * 
     * @type {string}
     * @memberof CreateOneProfileBody
     */
    'gender': CreateOneProfileBodyGenderEnum;
    /**
     * 
     * @type {Array<string>}
     * @memberof CreateOneProfileBody
     */
    'gendersToShow': Array<CreateOneProfileBodyGendersToShowEnum>;
    /**
     * 
     * @type {Array<string>}
     * @memberof CreateOneProfileBody
     */
    'trackIds': Array<string>;
}

export const CreateOneProfileBodyGenderEnum = {
    Male: 'MALE',
    Female: 'FEMALE',
    NonBinary: 'NON_BINARY'
} as const;

export type CreateOneProfileBodyGenderEnum = typeof CreateOneProfileBodyGenderEnum[keyof typeof CreateOneProfileBodyGenderEnum];
export const CreateOneProfileBodyGendersToShowEnum = {
    Male: 'MALE',
    Female: 'FEMALE',
    NonBinary: 'NON_BINARY'
} as const;

export type CreateOneProfileBodyGendersToShowEnum = typeof CreateOneProfileBodyGendersToShowEnum[keyof typeof CreateOneProfileBodyGendersToShowEnum];

/**
 * 
 * @export
 * @interface ImageData
 */
export interface ImageData {
    /**
     * 
     * @type {number}
     * @memberof ImageData
     */
    'height': number;
    /**
     * 
     * @type {string}
     * @memberof ImageData
     */
    'url': string;
    /**
     * 
     * @type {number}
     * @memberof ImageData
     */
    'width': number;
}
/**
 * 
 * @export
 * @interface ProfileData
 */
export interface ProfileData {
    /**
     * 
     * @type {UserProfileInfo}
     * @memberof ProfileData
     */
    'profileInfo': UserProfileInfo;
    /**
     * 
     * @type {UserInfo}
     * @memberof ProfileData
     */
    'userInfo': UserInfo;
    /**
     * 
     * @type {Array<SerializedTrack>}
     * @memberof ProfileData
     */
    'songs': Array<SerializedTrack>;
}
/**
 * 
 * @export
 * @interface ProfilesResponse
 */
export interface ProfilesResponse {
    /**
     * 
     * @type {Array<ProfileData>}
     * @memberof ProfilesResponse
     */
    'data': Array<ProfileData>;
    /**
     * 
     * @type {number}
     * @memberof ProfilesResponse
     */
    'total': number;
    /**
     * 
     * @type {number}
     * @memberof ProfilesResponse
     */
    'totalPages': number;
    /**
     * 
     * @type {number}
     * @memberof ProfilesResponse
     */
    'currentPage': number;
    /**
     * 
     * @type {number}
     * @memberof ProfilesResponse
     */
    'nextPage'?: number;
}
/**
 * 
 * @export
 * @interface SendMatchRequestResponse
 */
export interface SendMatchRequestResponse {
    /**
     * 
     * @type {SendMatchRequestResponseData}
     * @memberof SendMatchRequestResponse
     */
    'data': SendMatchRequestResponseData;
}
/**
 * 
 * @export
 * @interface SendMatchRequestResponseData
 */
export interface SendMatchRequestResponseData {
    /**
     * 
     * @type {boolean}
     * @memberof SendMatchRequestResponseData
     */
    'isMatch': boolean;
    /**
     * 
     * @type {UserInfo}
     * @memberof SendMatchRequestResponseData
     */
    'userInfo': UserInfo;
}
/**
 * 
 * @export
 * @interface SerializedTrack
 */
export interface SerializedTrack {
    /**
     * 
     * @type {string}
     * @memberof SerializedTrack
     */
    'uri'?: string;
    /**
     * 
     * @type {number}
     * @memberof SerializedTrack
     */
    'popularity'?: number;
    /**
     * 
     * @type {string}
     * @memberof SerializedTrack
     */
    'name'?: string;
    /**
     * 
     * @type {string}
     * @memberof SerializedTrack
     */
    'trackId'?: string;
    /**
     * 
     * @type {string}
     * @memberof SerializedTrack
     */
    'albumName'?: string;
    /**
     * 
     * @type {ImageData}
     * @memberof SerializedTrack
     */
    'albumImage'?: ImageData;
    /**
     * 
     * @type {Array<string>}
     * @memberof SerializedTrack
     */
    'artistNames': Array<string>;
}
/**
 * 
 * @export
 * @interface SerializedTracksResponse
 */
export interface SerializedTracksResponse {
    /**
     * 
     * @type {Array<SerializedTrack>}
     * @memberof SerializedTracksResponse
     */
    'data': Array<SerializedTrack>;
}
/**
 * 
 * @export
 * @interface UserInfo
 */
export interface UserInfo {
    /**
     * 
     * @type {string}
     * @memberof UserInfo
     */
    'avatarUri': string;
    /**
     * 
     * @type {string}
     * @memberof UserInfo
     */
    'id': string;
    /**
     * 
     * @type {string}
     * @memberof UserInfo
     */
    'name': string;
}
/**
 * 
 * @export
 * @interface UserInfoData
 */
export interface UserInfoData {
    /**
     * 
     * @type {UserInfoProfile}
     * @memberof UserInfoData
     */
    'profile'?: UserInfoProfile;
    /**
     * 
     * @type {string}
     * @memberof UserInfoData
     */
    'name': string;
    /**
     * 
     * @type {string}
     * @memberof UserInfoData
     */
    'id': string;
}
/**
 * 
 * @export
 * @interface UserInfoProfile
 */
export interface UserInfoProfile {
    /**
     * 
     * @type {string}
     * @memberof UserInfoProfile
     */
    'description'?: string;
    /**
     * 
     * @type {Array<string>}
     * @memberof UserInfoProfile
     */
    'gendersToShow': Array<UserInfoProfileGendersToShowEnum>;
    /**
     * 
     * @type {string}
     * @memberof UserInfoProfile
     */
    'gender': UserInfoProfileGenderEnum;
    /**
     * 
     * @type {Date}
     * @memberof UserInfoProfile
     */
    'dateOfBirth': Date;
}

export const UserInfoProfileGendersToShowEnum = {
    Male: 'MALE',
    Female: 'FEMALE',
    NonBinary: 'NON_BINARY'
} as const;

export type UserInfoProfileGendersToShowEnum = typeof UserInfoProfileGendersToShowEnum[keyof typeof UserInfoProfileGendersToShowEnum];
export const UserInfoProfileGenderEnum = {
    Male: 'MALE',
    Female: 'FEMALE',
    NonBinary: 'NON_BINARY'
} as const;

export type UserInfoProfileGenderEnum = typeof UserInfoProfileGenderEnum[keyof typeof UserInfoProfileGenderEnum];

/**
 * 
 * @export
 * @interface UserInfoResponse
 */
export interface UserInfoResponse {
    /**
     * 
     * @type {UserInfoData}
     * @memberof UserInfoResponse
     */
    'data': UserInfoData;
}
/**
 * 
 * @export
 * @interface UserProfileInfo
 */
export interface UserProfileInfo {
    /**
     * 
     * @type {string}
     * @memberof UserProfileInfo
     */
    'description'?: string;
    /**
     * 
     * @type {string}
     * @memberof UserProfileInfo
     */
    'gender': UserProfileInfoGenderEnum;
    /**
     * 
     * @type {Array<string>}
     * @memberof UserProfileInfo
     */
    'trackIds': Array<string>;
}

export const UserProfileInfoGenderEnum = {
    Male: 'MALE',
    Female: 'FEMALE',
    NonBinary: 'NON_BINARY'
} as const;

export type UserProfileInfoGenderEnum = typeof UserProfileInfoGenderEnum[keyof typeof UserProfileInfoGenderEnum];


/**
 * AuthApi - axios parameter creator
 * @export
 */
export const AuthApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        authControllerSsoSuccess: async (options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/auth/success`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * AuthApi - functional programming interface
 * @export
 */
export const AuthApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = AuthApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async authControllerSsoSuccess(options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<object>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.authControllerSsoSuccess(options);
            const index = configuration?.serverIndex ?? 0;
            const operationBasePath = operationServerMap['AuthApi.authControllerSsoSuccess']?.[index]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, operationBasePath || basePath);
        },
    }
};

/**
 * AuthApi - factory interface
 * @export
 */
export const AuthApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = AuthApiFp(configuration)
    return {
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        authControllerSsoSuccess(options?: any): AxiosPromise<object> {
            return localVarFp.authControllerSsoSuccess(options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * AuthApi - interface
 * @export
 * @interface AuthApi
 */
export interface AuthApiInterface {
    /**
     * 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AuthApiInterface
     */
    authControllerSsoSuccess(options?: RawAxiosRequestConfig): AxiosPromise<object>;

}

/**
 * AuthApi - object-oriented interface
 * @export
 * @class AuthApi
 * @extends {BaseAPI}
 */
export class AuthApi extends BaseAPI implements AuthApiInterface {
    /**
     * 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AuthApi
     */
    public authControllerSsoSuccess(options?: RawAxiosRequestConfig) {
        return AuthApiFp(this.configuration).authControllerSsoSuccess(options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * AuthMeApi - axios parameter creator
 * @export
 */
export const AuthMeApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        authMeControllerLogout: async (options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/auth/me/logout`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        authMeControllerRefreshToken: async (options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/auth/me/refresh`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * AuthMeApi - functional programming interface
 * @export
 */
export const AuthMeApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = AuthMeApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async authMeControllerLogout(options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.authMeControllerLogout(options);
            const index = configuration?.serverIndex ?? 0;
            const operationBasePath = operationServerMap['AuthMeApi.authMeControllerLogout']?.[index]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, operationBasePath || basePath);
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async authMeControllerRefreshToken(options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<AuthenticateUserResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.authMeControllerRefreshToken(options);
            const index = configuration?.serverIndex ?? 0;
            const operationBasePath = operationServerMap['AuthMeApi.authMeControllerRefreshToken']?.[index]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, operationBasePath || basePath);
        },
    }
};

/**
 * AuthMeApi - factory interface
 * @export
 */
export const AuthMeApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = AuthMeApiFp(configuration)
    return {
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        authMeControllerLogout(options?: any): AxiosPromise<void> {
            return localVarFp.authMeControllerLogout(options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        authMeControllerRefreshToken(options?: any): AxiosPromise<AuthenticateUserResponse> {
            return localVarFp.authMeControllerRefreshToken(options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * AuthMeApi - interface
 * @export
 * @interface AuthMeApi
 */
export interface AuthMeApiInterface {
    /**
     * 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AuthMeApiInterface
     */
    authMeControllerLogout(options?: RawAxiosRequestConfig): AxiosPromise<void>;

    /**
     * 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AuthMeApiInterface
     */
    authMeControllerRefreshToken(options?: RawAxiosRequestConfig): AxiosPromise<AuthenticateUserResponse>;

}

/**
 * AuthMeApi - object-oriented interface
 * @export
 * @class AuthMeApi
 * @extends {BaseAPI}
 */
export class AuthMeApi extends BaseAPI implements AuthMeApiInterface {
    /**
     * 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AuthMeApi
     */
    public authMeControllerLogout(options?: RawAxiosRequestConfig) {
        return AuthMeApiFp(this.configuration).authMeControllerLogout(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AuthMeApi
     */
    public authMeControllerRefreshToken(options?: RawAxiosRequestConfig) {
        return AuthMeApiFp(this.configuration).authMeControllerRefreshToken(options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * AuthSpotifyApi - axios parameter creator
 * @export
 */
export const AuthSpotifyApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        authSpotifyControllerAuthorize: async (options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/auth/spotify`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        authSpotifyControllerCallback: async (options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/auth/spotify/callback`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * AuthSpotifyApi - functional programming interface
 * @export
 */
export const AuthSpotifyApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = AuthSpotifyApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async authSpotifyControllerAuthorize(options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.authSpotifyControllerAuthorize(options);
            const index = configuration?.serverIndex ?? 0;
            const operationBasePath = operationServerMap['AuthSpotifyApi.authSpotifyControllerAuthorize']?.[index]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, operationBasePath || basePath);
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async authSpotifyControllerCallback(options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.authSpotifyControllerCallback(options);
            const index = configuration?.serverIndex ?? 0;
            const operationBasePath = operationServerMap['AuthSpotifyApi.authSpotifyControllerCallback']?.[index]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, operationBasePath || basePath);
        },
    }
};

/**
 * AuthSpotifyApi - factory interface
 * @export
 */
export const AuthSpotifyApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = AuthSpotifyApiFp(configuration)
    return {
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        authSpotifyControllerAuthorize(options?: any): AxiosPromise<void> {
            return localVarFp.authSpotifyControllerAuthorize(options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        authSpotifyControllerCallback(options?: any): AxiosPromise<void> {
            return localVarFp.authSpotifyControllerCallback(options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * AuthSpotifyApi - interface
 * @export
 * @interface AuthSpotifyApi
 */
export interface AuthSpotifyApiInterface {
    /**
     * 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AuthSpotifyApiInterface
     */
    authSpotifyControllerAuthorize(options?: RawAxiosRequestConfig): AxiosPromise<void>;

    /**
     * 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AuthSpotifyApiInterface
     */
    authSpotifyControllerCallback(options?: RawAxiosRequestConfig): AxiosPromise<void>;

}

/**
 * AuthSpotifyApi - object-oriented interface
 * @export
 * @class AuthSpotifyApi
 * @extends {BaseAPI}
 */
export class AuthSpotifyApi extends BaseAPI implements AuthSpotifyApiInterface {
    /**
     * 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AuthSpotifyApi
     */
    public authSpotifyControllerAuthorize(options?: RawAxiosRequestConfig) {
        return AuthSpotifyApiFp(this.configuration).authSpotifyControllerAuthorize(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AuthSpotifyApi
     */
    public authSpotifyControllerCallback(options?: RawAxiosRequestConfig) {
        return AuthSpotifyApiFp(this.configuration).authSpotifyControllerCallback(options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * MatchsApi - axios parameter creator
 * @export
 */
export const MatchsApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @param {number} [page] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        matchControllerGetProfilesToShow: async (page?: number, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/matchs`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (page !== undefined) {
                localVarQueryParameter['page'] = page;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * MatchsApi - functional programming interface
 * @export
 */
export const MatchsApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = MatchsApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @param {number} [page] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async matchControllerGetProfilesToShow(page?: number, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ProfilesResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.matchControllerGetProfilesToShow(page, options);
            const index = configuration?.serverIndex ?? 0;
            const operationBasePath = operationServerMap['MatchsApi.matchControllerGetProfilesToShow']?.[index]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, operationBasePath || basePath);
        },
    }
};

/**
 * MatchsApi - factory interface
 * @export
 */
export const MatchsApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = MatchsApiFp(configuration)
    return {
        /**
         * 
         * @param {number} [page] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        matchControllerGetProfilesToShow(page?: number, options?: any): AxiosPromise<ProfilesResponse> {
            return localVarFp.matchControllerGetProfilesToShow(page, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * MatchsApi - interface
 * @export
 * @interface MatchsApi
 */
export interface MatchsApiInterface {
    /**
     * 
     * @param {number} [page] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof MatchsApiInterface
     */
    matchControllerGetProfilesToShow(page?: number, options?: RawAxiosRequestConfig): AxiosPromise<ProfilesResponse>;

}

/**
 * MatchsApi - object-oriented interface
 * @export
 * @class MatchsApi
 * @extends {BaseAPI}
 */
export class MatchsApi extends BaseAPI implements MatchsApiInterface {
    /**
     * 
     * @param {number} [page] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof MatchsApi
     */
    public matchControllerGetProfilesToShow(page?: number, options?: RawAxiosRequestConfig) {
        return MatchsApiFp(this.configuration).matchControllerGetProfilesToShow(page, options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * MatchsUserIdRequestsApi - axios parameter creator
 * @export
 */
export const MatchsUserIdRequestsApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @param {string} userId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        matchRequestControllerSendMatchRequestToUser: async (userId: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'userId' is not null or undefined
            assertParamExists('matchRequestControllerSendMatchRequestToUser', 'userId', userId)
            const localVarPath = `/api/matchs/{userId}/requests`
                .replace(`{${"userId"}}`, encodeURIComponent(String(userId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * MatchsUserIdRequestsApi - functional programming interface
 * @export
 */
export const MatchsUserIdRequestsApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = MatchsUserIdRequestsApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @param {string} userId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async matchRequestControllerSendMatchRequestToUser(userId: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<SendMatchRequestResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.matchRequestControllerSendMatchRequestToUser(userId, options);
            const index = configuration?.serverIndex ?? 0;
            const operationBasePath = operationServerMap['MatchsUserIdRequestsApi.matchRequestControllerSendMatchRequestToUser']?.[index]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, operationBasePath || basePath);
        },
    }
};

/**
 * MatchsUserIdRequestsApi - factory interface
 * @export
 */
export const MatchsUserIdRequestsApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = MatchsUserIdRequestsApiFp(configuration)
    return {
        /**
         * 
         * @param {string} userId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        matchRequestControllerSendMatchRequestToUser(userId: string, options?: any): AxiosPromise<SendMatchRequestResponse> {
            return localVarFp.matchRequestControllerSendMatchRequestToUser(userId, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * MatchsUserIdRequestsApi - interface
 * @export
 * @interface MatchsUserIdRequestsApi
 */
export interface MatchsUserIdRequestsApiInterface {
    /**
     * 
     * @param {string} userId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof MatchsUserIdRequestsApiInterface
     */
    matchRequestControllerSendMatchRequestToUser(userId: string, options?: RawAxiosRequestConfig): AxiosPromise<SendMatchRequestResponse>;

}

/**
 * MatchsUserIdRequestsApi - object-oriented interface
 * @export
 * @class MatchsUserIdRequestsApi
 * @extends {BaseAPI}
 */
export class MatchsUserIdRequestsApi extends BaseAPI implements MatchsUserIdRequestsApiInterface {
    /**
     * 
     * @param {string} userId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof MatchsUserIdRequestsApi
     */
    public matchRequestControllerSendMatchRequestToUser(userId: string, options?: RawAxiosRequestConfig) {
        return MatchsUserIdRequestsApiFp(this.configuration).matchRequestControllerSendMatchRequestToUser(userId, options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * MeProfileApi - axios parameter creator
 * @export
 */
export const MeProfileApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @param {CreateOneProfileBody} createOneProfileBody 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        meProfileControllerCreateProfile: async (createOneProfileBody: CreateOneProfileBody, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'createOneProfileBody' is not null or undefined
            assertParamExists('meProfileControllerCreateProfile', 'createOneProfileBody', createOneProfileBody)
            const localVarPath = `/api/me/profile`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(createOneProfileBody, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        meProfileControllerGetAvatar: async (options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/me/profile/avatar`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        meProfileControllerGetInfo: async (options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/me/profile`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        meProfileControllerUploadAvatarFile: async (options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/me/profile/avatar`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * MeProfileApi - functional programming interface
 * @export
 */
export const MeProfileApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = MeProfileApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @param {CreateOneProfileBody} createOneProfileBody 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async meProfileControllerCreateProfile(createOneProfileBody: CreateOneProfileBody, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<UserInfoResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.meProfileControllerCreateProfile(createOneProfileBody, options);
            const index = configuration?.serverIndex ?? 0;
            const operationBasePath = operationServerMap['MeProfileApi.meProfileControllerCreateProfile']?.[index]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, operationBasePath || basePath);
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async meProfileControllerGetAvatar(options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.meProfileControllerGetAvatar(options);
            const index = configuration?.serverIndex ?? 0;
            const operationBasePath = operationServerMap['MeProfileApi.meProfileControllerGetAvatar']?.[index]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, operationBasePath || basePath);
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async meProfileControllerGetInfo(options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<UserInfoResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.meProfileControllerGetInfo(options);
            const index = configuration?.serverIndex ?? 0;
            const operationBasePath = operationServerMap['MeProfileApi.meProfileControllerGetInfo']?.[index]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, operationBasePath || basePath);
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async meProfileControllerUploadAvatarFile(options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.meProfileControllerUploadAvatarFile(options);
            const index = configuration?.serverIndex ?? 0;
            const operationBasePath = operationServerMap['MeProfileApi.meProfileControllerUploadAvatarFile']?.[index]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, operationBasePath || basePath);
        },
    }
};

/**
 * MeProfileApi - factory interface
 * @export
 */
export const MeProfileApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = MeProfileApiFp(configuration)
    return {
        /**
         * 
         * @param {CreateOneProfileBody} createOneProfileBody 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        meProfileControllerCreateProfile(createOneProfileBody: CreateOneProfileBody, options?: any): AxiosPromise<UserInfoResponse> {
            return localVarFp.meProfileControllerCreateProfile(createOneProfileBody, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        meProfileControllerGetAvatar(options?: any): AxiosPromise<void> {
            return localVarFp.meProfileControllerGetAvatar(options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        meProfileControllerGetInfo(options?: any): AxiosPromise<UserInfoResponse> {
            return localVarFp.meProfileControllerGetInfo(options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        meProfileControllerUploadAvatarFile(options?: any): AxiosPromise<void> {
            return localVarFp.meProfileControllerUploadAvatarFile(options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * MeProfileApi - interface
 * @export
 * @interface MeProfileApi
 */
export interface MeProfileApiInterface {
    /**
     * 
     * @param {CreateOneProfileBody} createOneProfileBody 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof MeProfileApiInterface
     */
    meProfileControllerCreateProfile(createOneProfileBody: CreateOneProfileBody, options?: RawAxiosRequestConfig): AxiosPromise<UserInfoResponse>;

    /**
     * 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof MeProfileApiInterface
     */
    meProfileControllerGetAvatar(options?: RawAxiosRequestConfig): AxiosPromise<void>;

    /**
     * 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof MeProfileApiInterface
     */
    meProfileControllerGetInfo(options?: RawAxiosRequestConfig): AxiosPromise<UserInfoResponse>;

    /**
     * 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof MeProfileApiInterface
     */
    meProfileControllerUploadAvatarFile(options?: RawAxiosRequestConfig): AxiosPromise<void>;

}

/**
 * MeProfileApi - object-oriented interface
 * @export
 * @class MeProfileApi
 * @extends {BaseAPI}
 */
export class MeProfileApi extends BaseAPI implements MeProfileApiInterface {
    /**
     * 
     * @param {CreateOneProfileBody} createOneProfileBody 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof MeProfileApi
     */
    public meProfileControllerCreateProfile(createOneProfileBody: CreateOneProfileBody, options?: RawAxiosRequestConfig) {
        return MeProfileApiFp(this.configuration).meProfileControllerCreateProfile(createOneProfileBody, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof MeProfileApi
     */
    public meProfileControllerGetAvatar(options?: RawAxiosRequestConfig) {
        return MeProfileApiFp(this.configuration).meProfileControllerGetAvatar(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof MeProfileApi
     */
    public meProfileControllerGetInfo(options?: RawAxiosRequestConfig) {
        return MeProfileApiFp(this.configuration).meProfileControllerGetInfo(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof MeProfileApi
     */
    public meProfileControllerUploadAvatarFile(options?: RawAxiosRequestConfig) {
        return MeProfileApiFp(this.configuration).meProfileControllerUploadAvatarFile(options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * SpotifyTracksApi - axios parameter creator
 * @export
 */
export const SpotifyTracksApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @param {string} query 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        spotifyTracksControllerGetTracksByName: async (query: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'query' is not null or undefined
            assertParamExists('spotifyTracksControllerGetTracksByName', 'query', query)
            const localVarPath = `/api/spotify/tracks/search`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (query !== undefined) {
                localVarQueryParameter['query'] = query;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        spotifyTracksControllerGetUserTopFiveTracks: async (options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/spotify/tracks/top-five`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * SpotifyTracksApi - functional programming interface
 * @export
 */
export const SpotifyTracksApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = SpotifyTracksApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @param {string} query 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async spotifyTracksControllerGetTracksByName(query: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<SerializedTracksResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.spotifyTracksControllerGetTracksByName(query, options);
            const index = configuration?.serverIndex ?? 0;
            const operationBasePath = operationServerMap['SpotifyTracksApi.spotifyTracksControllerGetTracksByName']?.[index]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, operationBasePath || basePath);
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async spotifyTracksControllerGetUserTopFiveTracks(options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<SerializedTracksResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.spotifyTracksControllerGetUserTopFiveTracks(options);
            const index = configuration?.serverIndex ?? 0;
            const operationBasePath = operationServerMap['SpotifyTracksApi.spotifyTracksControllerGetUserTopFiveTracks']?.[index]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, operationBasePath || basePath);
        },
    }
};

/**
 * SpotifyTracksApi - factory interface
 * @export
 */
export const SpotifyTracksApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = SpotifyTracksApiFp(configuration)
    return {
        /**
         * 
         * @param {string} query 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        spotifyTracksControllerGetTracksByName(query: string, options?: any): AxiosPromise<SerializedTracksResponse> {
            return localVarFp.spotifyTracksControllerGetTracksByName(query, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        spotifyTracksControllerGetUserTopFiveTracks(options?: any): AxiosPromise<SerializedTracksResponse> {
            return localVarFp.spotifyTracksControllerGetUserTopFiveTracks(options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * SpotifyTracksApi - interface
 * @export
 * @interface SpotifyTracksApi
 */
export interface SpotifyTracksApiInterface {
    /**
     * 
     * @param {string} query 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SpotifyTracksApiInterface
     */
    spotifyTracksControllerGetTracksByName(query: string, options?: RawAxiosRequestConfig): AxiosPromise<SerializedTracksResponse>;

    /**
     * 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SpotifyTracksApiInterface
     */
    spotifyTracksControllerGetUserTopFiveTracks(options?: RawAxiosRequestConfig): AxiosPromise<SerializedTracksResponse>;

}

/**
 * SpotifyTracksApi - object-oriented interface
 * @export
 * @class SpotifyTracksApi
 * @extends {BaseAPI}
 */
export class SpotifyTracksApi extends BaseAPI implements SpotifyTracksApiInterface {
    /**
     * 
     * @param {string} query 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SpotifyTracksApi
     */
    public spotifyTracksControllerGetTracksByName(query: string, options?: RawAxiosRequestConfig) {
        return SpotifyTracksApiFp(this.configuration).spotifyTracksControllerGetTracksByName(query, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SpotifyTracksApi
     */
    public spotifyTracksControllerGetUserTopFiveTracks(options?: RawAxiosRequestConfig) {
        return SpotifyTracksApiFp(this.configuration).spotifyTracksControllerGetUserTopFiveTracks(options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * UsersUserIdApi - axios parameter creator
 * @export
 */
export const UsersUserIdApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @param {string} userId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        userDetailControllerGetUserAvatar: async (userId: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'userId' is not null or undefined
            assertParamExists('userDetailControllerGetUserAvatar', 'userId', userId)
            const localVarPath = `/api/users/{userId}/profile/avatar`
                .replace(`{${"userId"}}`, encodeURIComponent(String(userId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * UsersUserIdApi - functional programming interface
 * @export
 */
export const UsersUserIdApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = UsersUserIdApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @param {string} userId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async userDetailControllerGetUserAvatar(userId: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.userDetailControllerGetUserAvatar(userId, options);
            const index = configuration?.serverIndex ?? 0;
            const operationBasePath = operationServerMap['UsersUserIdApi.userDetailControllerGetUserAvatar']?.[index]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, operationBasePath || basePath);
        },
    }
};

/**
 * UsersUserIdApi - factory interface
 * @export
 */
export const UsersUserIdApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = UsersUserIdApiFp(configuration)
    return {
        /**
         * 
         * @param {string} userId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        userDetailControllerGetUserAvatar(userId: string, options?: any): AxiosPromise<void> {
            return localVarFp.userDetailControllerGetUserAvatar(userId, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * UsersUserIdApi - interface
 * @export
 * @interface UsersUserIdApi
 */
export interface UsersUserIdApiInterface {
    /**
     * 
     * @param {string} userId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UsersUserIdApiInterface
     */
    userDetailControllerGetUserAvatar(userId: string, options?: RawAxiosRequestConfig): AxiosPromise<void>;

}

/**
 * UsersUserIdApi - object-oriented interface
 * @export
 * @class UsersUserIdApi
 * @extends {BaseAPI}
 */
export class UsersUserIdApi extends BaseAPI implements UsersUserIdApiInterface {
    /**
     * 
     * @param {string} userId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UsersUserIdApi
     */
    public userDetailControllerGetUserAvatar(userId: string, options?: RawAxiosRequestConfig) {
        return UsersUserIdApiFp(this.configuration).userDetailControllerGetUserAvatar(userId, options).then((request) => request(this.axios, this.basePath));
    }
}



